package DefHash; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Define things according to a specification, using hashes

=head1 SPECIFICATION VERSION

 1


=head1 ABSTRACT

This document describes DefHash, a specification for using hashes to define
things. DefHash was born out of several other projects/specifications like
L<Sah>, L<Rinci>, L<Riap>, L<Module::Patch>.


=head1 SPECIFICATION

In this document, hashes are written in JSON or pseudo-JSON (e.g. contains
ellipsis C<...> or JavaScript-style comments C<// ...>).

=head2 Definitions

=over 4

=item * B<defhash>

A regular hash, or dictionary (as it is called in Python), or associative array
(as it is called in PHP), or object (as it is called in JavaScript). A defhash
has B<properties>, which normally translates to the hash key/value pairs.
Property names normally translates to hash keys, while property values
translates to hash values. "Normally" is used here because property can have
attributes, which are also written as hash key/value pairs:

 {
     "v": 1,                         // set value for property 'v'
     "prop1": "value1",              // set value for property 'prop1'
     "prop2": ["value2", ...],       // set value for property 'prop2'
     "prop1.attr1": ...,             // set value for prop1's attribute
     "prop1.attr1.subattr1": ...,    // set value for prop1's attribute
     "_extra1": ...,                 // ignored property, starts with _
     "prop1._extra_attr": ...,       // ignored attribute, starts with _
 }

The above defhash defines two properties: C<prop1> and C<prop2>. C<prop1> has
two attributes, C<attr1> and C<attr1.subattr1>. Properties which start with
underscore (C<_>) are ignored; this can be used to put extraneous information.
Likewise for attributes which starts with underscore.

Property names must follow this regex '\A[a-z][a-z0-9_]*\z' (an
alphanumeric-only word). Property attributes must follow this regex:
'\A[a-z][a-z0-9_]*([a-z][a-z0-9_]*)*\z' (a dotted alphanumeric word).

Property value can be anything. It can contain another defhash for defining
subentities, for example. In Rinci, a function metadata has a property called
C<args> to define function arguments; its value is a hash of argument names and
argument specification. Each argument specification is a defhash.

Property attributes can be used to store extra data into a property.

=item * B<specification>

A set of recognized properties and property attributes, including whether the
properties are required, expected values (schema) for properties and attributes,
and default values.

For example, Rinci is a specification for function metadata (among others). One
writes a defhash (metadata) for a function, it contains properties to describe
the function. Rinci specifies what properties are available and the meaning and
expected values for each of those properties. An example of a Rinci function
metadata:

 // metadata for function 'sum'
 {
     "v": 2, // version of Rinci specification
     "summary": "Sum all the elements of array numerically",
     "description":
         "Non-numeric elements in array will be skipped. Empty array
          or no numeric elements in array will result in 0 for the
          sum.",
     "args": {
         "array": {
             "summary": "The array to sum",
             "schema": "array*",
         },
     },
 }

=back

=head2 Why write definitions in a hash?

Hash is a basic data structure that is supported by all high-level languages,
including Perl, Python, PHP, Ruby, and JavaScript. It is particularly easy to
merge. It makes checking the existence of value of property very easy, by just
accessing the hash's key.

B<... instead of text (like POD)?> Putting definition in a data structure makes
it easier to manipulate the definition (merge, parse, normalize, convert, etc).

B<... instead of array?> Hash allows us to evolve more easily. If we deprecate a
property or add new ones, elements don't have to shift like in array.

=head2 Common properties

These are the list of properties that all specifications must recognize:

=over 4

=item * B<v> => INT (default: 1)

Must not have attributes. This specifies the version of specification that the
defhash is following.

A specification can change over time. The C<v> property specifies the
specification version which the hash follows. Specification version is a
non-negative integer. If unspecified, it is assumed to be 1. But it can also be
0.

=item * B<defhash_v> => INT (default: 1)

Must not have attributes. This specifies the version of DefHash specification
itself. It is hoped that this should never change, so normally a defhash need
not specify this.

=item * B<summary> => TEXT

A short (usually single-word) name for the thing that is described. For example,
in Rinci function metadata, it is the function's name. In Sah, it is a name of
the schema that can be used by the human compiler.

 // metadata for function 'sum'
 {
     "name": "sum",
     ...
 }

 // schema for describing positive integer
 ["int", {
     "name": "pos_int",
     "min": 0,
 }]

=item * B<summary> => TEXT

A short (< 72 character), one-line summary about the thing that is described.
For example, in Rinci function metadata, the C<summary> describes what the
function does:

 // metadata for function 'sum'
 {
     "summary": "Sum all the elements of an array numerically",
     ...
 }

=item * B<description> => TEXT

A longer description. Normally a paragraph or longer of text. The text is
assumed to be marked up in Markdown.

=item * B<tags> => ARRAY[TEXT]

A list of one or more tags, can be used to categorize the thing that is
described.

=item * B<default_lang> => TEXT (default: en_US)

Default language.

=head2 Property attributes

Below is the list of property attributes that must be supported.

=over 4

=item * alt

This attribute can be used to store alternate property values. The most common
are:

 alt.lang.<LANG_CODE>

Example:

 {
     "summary": "An English summary",
     "summary.alt.lang.id_ID": "Ringkasan dalam bahasa Indonesia",
 }

Another example (alternate value for different language, C<lang>, and different
environment, C<env>; the ordering should be asciibetical and a care should be
taken to not be ambiguous, since attribute names can only be words):

 {
     "default_lang": "en_US",
     "summary": "An English summary",
     "summary.alt.env_lang.web.id_ID":"(Summary in Indonesian, for web)",
     "summary.alt.env_lang.cmdline.id_ID":"(Summary in Indonesian, for cmdline)"
 }

=back

=head2 When should specification version be increased?

When a backward-incompatible change is introduced. This is defined to be removal
of a recognized property, or the semantic change of an existing property, or
other incompatible change. For example,

 XXX (modp 1->2, 2->3; ri ->2, not using defhash but that is not the real reason, removal of features property)
 XXX riap also bumped to 2 just because it uses hash


=head1 SEE ALSO

Semantic Versioning, L<http://semver.org>

Markdown specification

=cut
